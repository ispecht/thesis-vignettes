for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
# Get the ancestry of person 1
if(sum(1 == labs[[4]]) != 1){
return(FALSE)
}else{
anc <- which(labs[[4]] == 1)
for (i in 4:2) {
anc <- c(h[[i]][anc[1]], anc)
}
}
all_labs <- unlist(labs)
is_unique <- c()
for (i in 1:4) {
if(sum(labs[[i]][anc[i]] == all_labs) == 1){
is_unique[i] <- T
}else{
is_unique[i] <- F
}
}
if(all(is_unique)){
return(T)
}else{
return(F)
}
}
N <- 100
res_unique <- mclapply(1:1e6, simulate_unique, N = N, mc.cores = 12)
mean(unlist(res_unique))
# Poisson(2) MGF
pois_mgf <- function(t){
exp(2 * (exp(t) - 1))
}
# q1 through q4
get_qs <- function(N){
q <- rep(NA, 4)
q[4] <- 1 - 4/N
for (i in 3:1) {
q[i] <- (1 - 4/N) * pois_mgf(log(q[i+1]))
}
q
}
qs <- get_qs(N)
# Degree sequence, starting at root thru 3rd generation (4th generation irrelevant)
ds <- rep(1, 4)
# Coalescent
coalescent <- function(N){
choose(N-1, 3) * factorial(3) * (1/N)^sum(ds) * prod((exp(qs - 1) * 2^ds) / factorial(ds))
}
coalescent(N)
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
labs
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
labs
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
labs
h
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
labs
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
labs
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
labs
sum(1 == labs[[4]]) != 1
anc <- which(labs[[4]] == 1)
anc
h
for (i in 4:2) {
anc <- c(h[[i]][anc[1]], anc)
}
anc
all_labs <- unlist(labs)
length(unique(all_labs))
is_unique <- c()
for (i in 1:4) {
if(sum(labs[[i]][anc[i]] == all_labs) == 1){
is_unique[i] <- T
}else{
is_unique[i] <- F
}
}
i = 3
(exp(qs - 1) * 2^ds) / factorial(ds)
i = 3
labs[[i]][anc[i]]
labs
qs
# Coalescent
coalescent <- function(N){
choose(N-1, 3) * factorial(3) * (1/N)^sum(ds) * prod((exp(get_qs(N) - 1) * 2^ds) / factorial(ds))
}
coalescent(N)
coalescent(3)
coalescent(5)
qs()
qs(5)
get_qs(5)
# Function that returns TRUE if the finite-population Galton-Watson process contains a UNIQUE isomorphic subtree to (R,g) such that kappa(L) = Lambda(phi(L)); FALSE otherwise.
simulate_unique <- function(z, N){
# Draw the number of nodes in generation i, n[i]
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
#labs
if(sum(1 %in% labs[[1]]) == 1){
return(T)
}else{
return(F)
}
# Get the ancestry of person 1
if(sum(1 == labs[[4]]) != 1){
return(FALSE)
}else{
anc <- which(labs[[4]] == 1)
for (i in 4:2) {
anc <- c(h[[i]][anc[1]], anc)
}
}
all_labs <- unlist(labs)
is_unique <- c()
for (i in 1:4) {
if(sum(labs[[i]][anc[i]] == all_labs) == 1){
is_unique[i] <- T
}else{
is_unique[i] <- F
}
}
# if(all(is_unique)){
#   return(T)
# }else{
#   return(F)
# }
}
N <- 100
res_unique <- mclapply(1:1e6, simulate_unique, N = N, mc.cores = 12)
mean(unlist(res_unique))
# Function that returns TRUE if the finite-population Galton-Watson process contains a UNIQUE isomorphic subtree to (R,g) such that kappa(L) = Lambda(phi(L)); FALSE otherwise.
simulate_unique <- function(z, N){
# Draw the number of nodes in generation i, n[i]
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
#labs
# Get the ancestry of person 1
if(sum(1 == labs[[4]]) != 1){
return(FALSE)
}else{
anc <- which(labs[[4]] == 1)
for (i in 4:2) {
anc <- c(h[[i]][anc[1]], anc)
}
}
all_labs <- unlist(labs)
is_unique <- c()
for (i in 1:4) {
if(sum(labs[[i]][anc[i]] == all_labs) == 1){
is_unique[i] <- T
}else{
is_unique[i] <- F
}
}
}
N <- 100
res_unique <- mclapply(1:1e6, simulate_unique, N = N, mc.cores = 12)
mean(unlist(res_unique))
# Poisson(2) MGF
pois_mgf <- function(t){
exp(2 * (exp(t) - 1))
}
# q1 through q4
get_qs <- function(N){
q <- rep(NA, 4)
q[4] <- 1 - 4/N
for (i in 3:1) {
q[i] <- (1 - 4/N) * pois_mgf(log(q[i+1]))
}
q
}
qs <- get_qs(N)
# Degree sequence, starting at root thru 3rd generation (4th generation irrelevant)
ds <- rep(1, 4)
# Coalescent
coalescent <- function(N){
choose(N-1, 3) * factorial(3) * (1/N)^sum(ds) * prod((exp((get_qs(N) - 1)*2) * 2^ds) / factorial(ds))
}
coalescent(N)
# Function that returns TRUE if the finite-population Galton-Watson process contains a UNIQUE isomorphic subtree to (R,g) such that kappa(L) = Lambda(phi(L)); FALSE otherwise.
simulate_unique <- function(z, N){
# Draw the number of nodes in generation i, n[i]
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
#labs
# Get the ancestry of person 1
if(sum(1 == labs[[4]]) != 1){
return(FALSE)
}else{
anc <- which(labs[[4]] == 1)
for (i in 4:2) {
anc <- c(h[[i]][anc[1]], anc)
}
}
all_labs <- unlist(labs)
is_unique <- c()
for (i in 1:4) {
if(sum(labs[[i]][anc[i]] == all_labs) == 1){
is_unique[i] <- T
}else{
is_unique[i] <- F
}
}
if(all(is_unique)){
return(T)
}else{
return(F)
}
}
N <- 100
res_unique <- mclapply(1:1e6, simulate_unique, N = N, mc.cores = 12)
mean(unlist(res_unique))
# Poisson(2) MGF
pois_mgf <- function(t){
exp(2 * (exp(t) - 1))
}
# q1 through q4
get_qs <- function(N){
q <- rep(NA, 4)
q[4] <- 1 - 4/N
for (i in 3:1) {
q[i] <- (1 - 4/N) * pois_mgf(log(q[i+1]))
}
q
}
qs <- get_qs(N)
# Degree sequence, starting at root thru 3rd generation (4th generation irrelevant)
ds <- rep(1, 4)
# Coalescent
coalescent <- function(N){
choose(N-1, 3) * factorial(3) * (1/N)^sum(ds) * prod((exp((get_qs(N) - 1)*2) * 2^ds) / factorial(ds))
}
coalescent(N)
# Function that returns TRUE if the finite-population Galton-Watson process contains a UNIQUE isomorphic subtree to (R,g) such that kappa(L) = Lambda(phi(L)); FALSE otherwise.
simulate_unique <- function(z, N){
# Draw the number of nodes in generation i, n[i]
n <- c()
# Ancestor function
h <- list()
# Labels
labs <- list()
for (i in 1:4) {
if(i == 1){
n[i] <- rpois(1, 2)
h[[i]] <- rep(0, n[i])
}else{
h[[i]] <- integer(0)
if(n[i-1] > 0){
for (j in 1:n[i-1]) {
h[[i]] <- c(h[[i]], rep(j, rpois(1, 2)))
}
}
n[i] <- length(h[[i]])
}
labs[[i]] <- sample(1:N, n[i], replace = T)
}
#labs
# Get the ancestry of person 1
if(sum(1 == labs[[4]]) != 1){
return(FALSE)
}else{
anc <- which(labs[[4]] == 1)
for (i in 4:2) {
anc <- c(h[[i]][anc[1]], anc)
}
}
all_labs <- unlist(labs)
is_unique <- c()
for (i in 1:4) {
if(sum(labs[[i]][anc[i]] == all_labs) == 1){
is_unique[i] <- T
}else{
is_unique[i] <- F
}
}
if(all(is_unique)){
return(T)
}else{
return(F)
}
}
N <- 10
res_unique <- mclapply(1:1e6, simulate_unique, N = N, mc.cores = 12)
mean(unlist(res_unique))
# Poisson(2) MGF
pois_mgf <- function(t){
exp(2 * (exp(t) - 1))
}
# q1 through q4
get_qs <- function(N){
q <- rep(NA, 4)
q[4] <- 1 - 4/N
for (i in 3:1) {
q[i] <- (1 - 4/N) * pois_mgf(log(q[i+1]))
}
q
}
qs <- get_qs(N)
# Degree sequence, starting at root thru 3rd generation (4th generation irrelevant)
ds <- rep(1, 4)
# Coalescent
coalescent <- function(N){
choose(N-1, 3) * factorial(3) * (1/N)^sum(ds) * prod((exp((get_qs(N) - 1)*2) * 2^ds) / factorial(ds))
}
coalescent(N)
#(1/N) * (exp((1 - 1/N) - 1) * 2^ds)
